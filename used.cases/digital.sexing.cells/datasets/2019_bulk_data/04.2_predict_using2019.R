

library(ggplot2)
library(gridExtra)
#################################################
## read in meta information
df.meta=data.table::fread('sample.meta_sex.label.txt');# from 02_calTPM_PCA.R 

###################################################
## read in STAR output tab-limited read count data
files=Sys.glob('GSE127176_RAW/*tab')
files
raw.expr=list();
for(file in files){
  gsm=strsplit(basename(file),'_')[[1]][1]
  x=read.table(file,skip=4)
  raw.expr[[gsm]]=x
}
length(raw.expr) #54

# extract 'expressed genes', defined by >=21 counts in >=5 embryos
per.embryo.gene=lapply(raw.expr,function(x){
  x[x[,2]>=21,1]
})
sapply(per.embryo.gene,length)
expr.genes=names(which(table(unlist(per.embryo.gene))>=5))
length(expr.genes) #8983 genes
filtered.expr=lapply(raw.expr,function(x){
  x[x[,1] %in% expr.genes,]
})
sapply(filtered.expr,nrow) #8983 genes

#################################################
## TPM: read.count/gene.length
## then divided/ sum(length.corrented.count) x 10^6
df.info=data.table::fread('dme7_geneLength_chr.txt')
#query.genes=scan('all.gene.names.txt',what='')
query.genes=expr.genes
head(query.genes)
length(query.genes) #8983
sum(df.info$GENEID %in% query.genes) #8934
tmp=merge(filtered.expr[[1]],df.info,by.x='V1',by.y='GENEID')
length.corrected.counts=lapply(filtered.expr,function(x){
  tmp=merge(x,df.info,by.x='V1',by.y='GENEID')
  tmp$V2/tmp$exonic.gene.sizes/1000 #in kilobase
})
sapply(length.corrected.counts,length)
TPM=lapply(length.corrected.counts,function(x){
  x/sum(x)*10^6
})
log2.TPM=lapply(TPM,function(i) log(i+1,base=2))

## remove 5 PB samples
library(multiclassPairs)
log2TPM.df=Reduce(`cbind`,log2.TPM)
dim(log2TPM.df) #8934 x 54
rownames(log2TPM.df)=tmp[,1]
colnames(log2TPM.df)=names(log2.TPM)
log2TPM.df[1:3,1:3]

sum(df.meta$GSM.id==colnames(log2TPM.df)) #54
expr.mat=log2TPM.df[,df.meta$cluster!='PB']
sample.meta=df.meta[df.meta$cluster!='PB',]
sum(sample.meta$GSM.id==colnames(expr.mat)) #34

## change FBgn to gene symbol
gene.id=data.table::fread('validate.id_2019_paper_data.txt')
fbgn=rownames(expr.mat)
x=gene.id[match(fbgn,gene.id$FLYBASE),]
sum(x$FLYBASE==fbgn) #8934
dim(expr.mat)
rownames(expr.mat)=x$SYMBOL
expr.mat[1:3,1:3]

# due to gene name with '-' are not allowed in `multiclassPairs`
rownames(expr.mat)=gsub('-','_',rownames(expr.mat))

##########################################################################
## https://github.com/NourMarzouka/multiclassPairs/blob/master/README.md
library(multiclassPairs)

# split the data
# 60% as training data and 40% as testing data
n <- ncol(expr.mat)
set.seed(1234)
training_samples <- sample(1:n,size = n*0.6)
table(sample.meta[training_samples,]$cluster)
table(sample.meta[-training_samples,]$cluster)

train <- expr.mat[,training_samples]
test  <- expr.mat[,-training_samples]
train.meta <- sample.meta[training_samples,]
test.meta <- sample.meta[-training_samples,]

## read in embryo data
x=readRDS('prepared_embryo.data.rds')
test=as.matrix(x$umi.mat)
test.meta=x$sample.meta
class(test)
sum(rownames(test) %in% rownames(train))
shared.gene.names=rownames(test)[rownames(test) %in% rownames(train)]
shared.gene.names[grep('Sxl|msl|roX|mle|mof',shared.gene.names)]

train=train[shared.gene.names,]
test=test[shared.gene.names,]

# create data object 
object <- ReadData(Data = expr.mat,
                  Labels = sample.meta$cluster,
                  #Data = train,
                  #Labels = train.meta$cluster,
                  verbose = FALSE)
object

## data-driven filter genes
filtered_genes <- filter_genes_TSP(data_object = object,
                                   filter = "one_vs_one",
                                   platform_wise = FALSE,
                                   featureNo = 1000,
                                   UpDown = TRUE,
                                   verbose = TRUE)
filtered_genes

#########################################################
## use prior gene set
# using the object that is generated by ReadData
# we can create genes object with all genes to skip filtering step

# Get the class names
classes <- unique(object$data$Labels)

# create empty genes object
genes_all <- list(OnevsrestScheme = list(filtered_genes = NULL,
                                         calls = c()))
class(genes_all) <- "OnevsrestScheme_genes_TSP"

# prepare the slots for each class
tmp <- vector("list", length(classes))
names(tmp) <- classes

genes_all$OnevsrestScheme$filtered_genes <- tmp
genes_all$OnevsrestScheme$calls <- c()
genes_all

# fill the gene object in each slot
prior.genes=rownames(object$data$Data)[grep('Sxl|roX|mle|mof|msl',rownames(object$data$Data))]
prior.genes
for (i in classes) {
  #genes_all$OnevsrestScheme$filtered_genes[[i]] <- rownames(object$data$Data)
  genes_all$OnevsrestScheme$filtered_genes[[i]] <- prior.genes
}

# This is the gene object with all genes
genes_all
filtered_genes=genes_all

#####################################################
# Let's train our model
classifier <- train_one_vs_rest_TSP(data_object = object,
                                    filtered_genes = filtered_genes,
                                    k_range = 10:500,
                                    include_pivot = FALSE,
                                    one_vs_one_scores = TRUE,
                                    platform_wise_scores = FALSE,
                                    seed = 1234,
                                    verbose = FALSE)
classifier
classifier$classifiers$female
classifier$classifiers$male



# apply on the training data
# To have the classes in output in specific order, we can use classes argument
results_train <- predict_one_vs_rest_TSP(classifier = classifier,
                                         Data = object,
                                         tolerate_missed_genes = TRUE,
                                         weighted_votes = TRUE,
                                         classes = c("female",'male'),
                                         verbose = TRUE)
# apply on the testing data
results_test <- predict_one_vs_rest_TSP(classifier = classifier,
                                        Data = test,
                                        tolerate_missed_genes = TRUE,
                                        weighted_votes = TRUE,
                                        classes = c("female",'male'),
                                        verbose = TRUE)
# get a look over the scores in the testing data
knitr::kable(head(results_train))
table(results_train$max_score)

knitr::kable(head(results_test))
table(results_test$max_score)

# Confusion Matrix and Statistics on training data
caret::confusionMatrix(data = factor(results_train$max_score, 
                                     levels = unique(object$data$Labels)),
                       reference = factor(object$data$Labels, 
                                          levels = unique(object$data$Labels)),
                       mode="everything")


plot_binary_TSP(Data = object, # we are using the data object here
                classifier = classifier, 
                prediction = results_train, 
                classes =  c("female",'male'),
                margin = c(0,5,0,10),
                title = "Training data")

table(results_test$max_score)
sum(test.meta[test.meta$sex=='male',]$barcode %in% rownames(results_test[results_test$max_score=='male',]))

# I suspect the overlapped 78 male cells are those cells expressing roX2
cell.names=intersect(test.meta[test.meta$sex=='male',]$barcode ,
                       rownames(results_test[results_test$max_score=='male',]))
tmp=test['lncRNA:roX2',cell.names] #78 cells in total
sum(tmp==0) #55 not express roX2

