
library(ggplot2)
library(gridExtra)
#################################################
## read in meta information
df=read.table('GSE25180_series_matrix.txt',skip=30,sep='\t',fill=TRUE)
head(df)
df=t(df[c(1,40,44),])
df=df[-1,]
df
tmp=basename(df[,2])
tmp=gsub('.bedgraph.gz','',tmp)
id.check=unlist(lapply(strsplit(tmp,'\\_'),'[',1))
sum(id.check==df[,3]) #24 checked
sample.id=gsub('GSM\\d.+?_','',tmp)
sample.id

df=cbind(df[,c(1,3)],sample.id)
colnames(df)=c('sample.info','GSM.id','sample.id')
df.meta=as.data.frame(df);
dim(df.meta) #24 samples

df.meta$stage=gsub('F|M|U|_r2','',df.meta$sample.id)
df.meta$sex=substr(df.meta$sample.id,0,1)
table(df.meta$stage)
table(df.meta$sex)

###################################################
## read in STAR output tab-limited read count data
dat=read.table('2011-embryo_normalized.read.count.data.txt',
               header=T,fill=T)
dim(dat) #12353    79
dat[1:3,1:9]

colnames(dat)
mat=dat[,-(1:7)]

#We were thus able to partition the overall expression of any mRNA containing w1-CaS differences into its maternal and zygotic component
#7meta+24embryo.sample+24 w1 mother sample+24 Canton-S father sample
x=mat[,c(1,1+24,1+24+24)]
tmp=x[,2]+x[,3]
cbind(x[,1],tmp)

expr.mat=mat[,1:24];
colnames(expr.mat)
sum(colnames(expr.mat) %in% df.meta$sample.id) #24 matched

rownames(expr.mat)=dat[,1]
apply(expr.mat,2,function(i){sum(i,na.rm=T)})

#RPKM=expr.mat
#log2.RPKM=log(RPKM+1,base=2)

## change gene names 
gene.id=data.table::fread('validate.id_2011_paper_data.txt')
dim(expr.mat) #12353
fbgn=rownames(expr.mat)
sum(fbgn %in% gene.id$query) #12003
expr.mat=expr.mat[fbgn %in% gene.id$query,]
fbgn=rownames(expr.mat)

x=gene.id[match(fbgn,gene.id$query),]
sum(x$query==fbgn) #8934
rownames(expr.mat)=x$SYMBOL
expr.mat[1:3,1:3]


# due to gene name with '-' are not allowed in `multiclassPairs`
rownames(expr.mat)=gsub('-','_',rownames(expr.mat))

# limit to samples with NA
expr.mat[grep('Sxl|roX|mls|mle|mof',rownames(expr.mat)),]
expr.mat[,24]
x=apply(expr.mat,2,function(i) sum(is.na(i)))
x

## remove the 3 U sample
df.meta$sample.id;
colnames(expr.mat)
rownames(df.meta)=df.meta$sample.id
df.meta=df.meta[colnames(expr.mat),]

df.meta[df.meta$sex=='U',]$sex='F'
sample.meta=df.meta[df.meta$sex!='U' & df.meta$stage>=12 &
                      !df.meta$sample.id %in% c('M14D','M14D_r2'), ]
expr.mat=expr.mat[,df.meta$sex!='U' & df.meta$stage>=12 &
                    !df.meta$sample.id %in% c('M14D','M14D_r2') ]
dim(expr.mat)
dim(sample.meta)
table(sample.meta$sex)

##########################################################################
## https://github.com/NourMarzouka/multiclassPairs/blob/master/README.md
library(multiclassPairs)

# split the data
# 60% as training data and 40% as testing data
n <- ncol(expr.mat)
set.seed(2124)
training_samples <- sample(1:n,size = n*0.6)
table(sample.meta[training_samples,]$sex)
table(sample.meta[-training_samples,]$sex)

train <- expr.mat[,training_samples]
test  <- expr.mat[,-training_samples]
train.meta <- sample.meta[training_samples,]
test.meta <- sample.meta[-training_samples,]

# create data object 
object <- ReadData(#Data = expr.mat,
                   #Labels=sample.meta$sex,
                   Data = train,
                   Labels = train.meta$sex,
                   verbose = FALSE)
object
#########################################################3
## data-driven filter genes
filtered_genes <- filter_genes_TSP(data_object = object,
                                   filter = "one_vs_one",
                                   platform_wise = FALSE,
                                   featureNo = 2000,
                                   UpDown = TRUE,
                                   verbose = TRUE)
filtered_genes
length(filtered_genes$OnevsrestScheme$filtered_genes$F)
length(filtered_genes$OnevsrestScheme$filtered_genes$M)
#########################################################
## use prior gene set
# using the object that is generated by ReadData
# we can create genes object with all genes to skip filtering step

# Get the class names
classes <- unique(object$data$Labels)

# create empty genes object
genes_all <- list(OnevsrestScheme = list(filtered_genes = NULL,
                                         calls = c()))
class(genes_all) <- "OnevsrestScheme_genes_TSP"

# prepare the slots for each class
tmp <- vector("list", length(classes))
names(tmp) <- classes

genes_all$OnevsrestScheme$filtered_genes <- tmp
genes_all$OnevsrestScheme$calls <- c()
genes_all

# fill the gene object in each slot
prior.genes=rownames(object$data$Data)[grep('Sxl|roX|mle|mof|msl',rownames(object$data$Data))]
prior.genes
for (i in classes) {
  #genes_all$OnevsrestScheme$filtered_genes[[i]] <- rownames(object$data$Data)
  genes_all$OnevsrestScheme$filtered_genes[[i]] <- prior.genes
}

# This is the gene object with all genes
genes_all
filtered_genes=genes_all
#####################################################
# Let's train our model
classifier <- train_one_vs_rest_TSP(data_object = object,
                                    filtered_genes = filtered_genes,
                                    k_range = 2:500,
                                    include_pivot = FALSE,
                                    one_vs_one_scores = TRUE,
                                    platform_wise_scores = FALSE,
                                    seed = 1234,
                                    verbose = FALSE)
classifier
classifier$classifiers
names(classifier$classifiers)

# apply on the training data
# To have the classes in output in specific order, we can use classes argument
results_train <- predict_one_vs_rest_TSP(classifier = classifier,
                                         Data = object,
                                         tolerate_missed_genes = TRUE,
                                         weighted_votes = TRUE,
                                         classes = c("F",'M'),
                                         verbose = TRUE)
# apply on the testing data
results_test <- predict_one_vs_rest_TSP(classifier = classifier,
                                        Data = test,
                                        tolerate_missed_genes = TRUE,
                                        weighted_votes = TRUE,
                                        classes = c("F",'M'),
                                        verbose = TRUE)
# get a look over the scores in the testing data
knitr::kable(head(results_train))
table(results_train$max_score)

knitr::kable(head(results_test))
table(results_test$max_score)

# Confusion Matrix and Statistics on training data
caret::confusionMatrix(data = factor(results_train$max_score, 
                                     levels = unique(object$data$Labels)),
                       reference = factor(object$data$Labels, 
                                          levels = unique(object$data$Labels)),
                       mode="everything")

# Confusion Matrix and Statistics on testing data
caret::confusionMatrix(data = factor(results_test$max_score, 
                                     levels = unique(object$data$Labels)),
                       reference = factor(test.meta$sex,
                                          levels = unique(object$data$Labels)),
                       mode="everything")

# Visualiation
# plot for the rules and scores in the training data
pdf("TSP_out.pdf")
plot_binary_TSP(Data = object, # we are using the data object here
                classifier = classifier, 
                prediction = results_train, 
                classes =  c("F",'M'),
                margin = c(0,5,0,10),
                title = "Training data")

# plot for the rules and scores in the testing data
plot_binary_TSP(Data = test, # ExpressionSet
                ref = test.meta$sex,
                classifier = classifier, 
                prediction = results_test, 
                classes =  c("F",'M'),
                title = "Testing data",
                margin = c(0,5,0,10))
dev.off()



