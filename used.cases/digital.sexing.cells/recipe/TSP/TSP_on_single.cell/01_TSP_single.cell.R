
library(ggplot2)
library(gridExtra)
library(Seurat)

dat.both=readRDS('../../../single.cell_sex.differences/embryo_sex.cells/integrated.sexed.samples_seurat.obj.rds')
grep("Sxl|msl-2",rownames(dat.both))

##########################################################################
## https://github.com/NourMarzouka/multiclassPairs/blob/master/README.md
library(multiclassPairs)

# sample 1000 female and 1000 male
set.seed(220317)
i=sample(which(dat.both@meta.data$sex=='embryoFemale'),1000,replace = F)
j=sample(which(dat.both@meta.data$sex=='embryoMale'),1000,replace = F)

sample.meta=dat.both@meta.data[c(i,j),]
expr.mat=as.matrix(dat.both@assays$RNA@counts[,c(i,j)])

# due to gene name with '-' are not allowed in `multiclassPairs`
rownames(expr.mat)=gsub('-','_',rownames(expr.mat))

# split the data
# 60% as training data and 40% as testing data
n <- ncol(expr.mat)
set.seed(2124)
training_samples <- sample(1:n,size = n*0.6)
table(sample.meta[training_samples,]$sex)
table(sample.meta[-training_samples,]$sex)

train <- expr.mat[,training_samples]
test  <- expr.mat[,-training_samples]
train.meta <- sample.meta[training_samples,]
test.meta <- sample.meta[-training_samples,]

# create data object 
object <- ReadData(#Data = expr.mat,
                   #Labels=sample.meta$sex,
                   Data = train,
                   Labels = train.meta$sex,
                   verbose = FALSE)
object

#########################################################3
## data-driven filter genes
filtered_genes <- filter_genes_TSP(data_object = object,
                                   filter = "one_vs_one",
                                   platform_wise = FALSE,
                                   featureNo = 200,
                                   UpDown = TRUE,
                                   verbose = TRUE)
filtered_genes
names(filtered_genes$OnevsrestScheme$filtered_genes)

#########################################################
## use prior gene set
# using the object that is generated by ReadData
# we can create genes object with all genes to skip filtering step
if(F){
# Get the class names
classes <- unique(object$data$Labels)

# create empty genes object
genes_all <- list(OnevsrestScheme = list(filtered_genes = NULL,
                                         calls = c()))
class(genes_all) <- "OnevsrestScheme_genes_TSP"

# prepare the slots for each class
tmp <- vector("list", length(classes))
names(tmp) <- classes

genes_all$OnevsrestScheme$filtered_genes <- tmp
genes_all$OnevsrestScheme$calls <- c()
genes_all

# fill the gene object in each slot
prior.genes=rownames(object$data$Data)[grep('Sxl|roX|mle|mof|msl',rownames(object$data$Data))]
prior.genes
for (i in classes) {
  #genes_all$OnevsrestScheme$filtered_genes[[i]] <- rownames(object$data$Data)
  genes_all$OnevsrestScheme$filtered_genes[[i]] <- prior.genes
}

# This is the gene object with all genes
genes_all
filtered_genes=genes_all
}

#####################################################
# Let's train our model
classifier <- train_one_vs_rest_TSP(data_object = object,
                                    filtered_genes = filtered_genes,
                                    k_range = 2:500,
                                    include_pivot = FALSE,
                                    one_vs_one_scores = TRUE,
                                    platform_wise_scores = FALSE,
                                    seed = 1234,
                                    verbose = FALSE)
classifier
classifier$classifiers
names(classifier$classifiers)
classifier$classifiers$embryoFemale

# apply on the training data
# To have the classes in output in specific order, we can use classes argument
classes <- unique(object$data$Labels)
results_train <- predict_one_vs_rest_TSP(classifier = classifier,
                                         Data = object,
                                         tolerate_missed_genes = TRUE,
                                         weighted_votes = TRUE,
                                         classes = classes,
                                         verbose = TRUE)
# apply on the testing data
results_test <- predict_one_vs_rest_TSP(classifier = classifier,
                                        Data = test,
                                        tolerate_missed_genes = TRUE,
                                        weighted_votes = TRUE,
                                        classes = classes,
                                        verbose = TRUE)
# get a look over the scores in the testing data
knitr::kable(head(results_train))
table(results_train$max_score)

knitr::kable(head(results_test))
table(results_test$max_score)

# Confusion Matrix and Statistics on training data
caret::confusionMatrix(data = factor(results_train$max_score, 
                                     levels = unique(object$data$Labels)),
                       reference = factor(object$data$Labels, 
                                          levels = unique(object$data$Labels)),
                       mode="everything")

# Confusion Matrix and Statistics on testing data
caret::confusionMatrix(data = factor(results_test$max_score, 
                                     levels = unique(object$data$Labels)),
                       reference = factor(test.meta$sex,
                                          levels = unique(object$data$Labels)),
                       mode="everything")

# Visualiation
# plot for the rules and scores in the training data
pdf("TSP_out.pdf")
plot_binary_TSP(Data = object, # we are using the data object here
                classifier = classifier, 
                prediction = results_train, 
                classes =  classes,
                margin = c(0,8,0,10),
                title = "Training data")

# plot for the rules and scores in the testing data
plot_binary_TSP(Data = test, # ExpressionSet
                ref = test.meta$sex,
                classifier = classifier, 
                prediction = results_test, 
                classes =  classes,
                title = "Testing data",
                margin = c(0,8,0,10))
dev.off()



